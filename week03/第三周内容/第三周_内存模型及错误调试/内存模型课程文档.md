### 1、内存模型
代码区：存放函数体的二进制代码，由操作系统进行管理的
全局区：存放全局变量和静态变量以及常量
栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等
堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收

**全局变量与局部变量**
全局变量和局部变量是存在两个不同的区域的，且局部变量会在函数调用结束后就会被释放

**开辟堆区**
在C++中，可以使用new手动开辟堆区，使用delete释放堆区

### 2、引用
引用——相当于给变量起别名。也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量：
```c++
    #include <iostream>

    int main() 
    {
    int a = 10;
    int &b = a;
    std::cout << "a = " << a << std::endl;
    std::cout << "b = " << b << std::endl;
    b = 100;
    std::cout << "a = " << a << std::endl;
    std::cout << "b = " << b << std::endl;
    return 0;
    }
```
**C++ 引用 vs 指针**
引用很容易与指针混淆，它们之间有三个主要的不同：

1、不存在空引用。引用必须连接到一块合法的内存。
2、一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
3、引用必须在创建时被初始化。指针可以在任何时间被初始化。

**引用通常用于函数参数列表**
引用传参相对于直接传参的区别为
***引用传参传递参数本身，直接传参则传递参数的拷贝值***
例如如下程序：
```c++
#include <iostream>
using namespace std;
 
// 函数声明
void swap1(int& x, int& y);
void swap2(int x, int y)；
 
int main ()
{
   // 局部变量声明
   int a = 100;
   int b = 200;
 
   cout << "交换前，a 的值：" << a << endl;
   cout << "交换前，b 的值：" << b << endl;

   swap2(a, b);

   cout << "交换前，a 的值：" << a << endl;
   cout << "交换前，b 的值：" << b << endl;
 
   /* 调用函数来交换值 */
   swap1(a, b);
 
   cout << "交换后，a 的值：" << a << endl;
   cout << "交换后，b 的值：" << b << endl;
 
   return 0;
}
 
// 函数定义 引用传参
void swap1(int& x, int& y)
{
   int temp;
   temp = x; /* 保存地址 x 的值 */
   x = y;    /* 把 y 赋值给 x */
   y = temp; /* 把 x 赋值给 y  */
  
   return;
}
// 函数定义 直接传参
void swap2(int x, int y)
{
   int temp;
   temp = x; /* 保存地址 x 的值 */
   x = y;    /* 把 y 赋值给 x */
   y = temp; /* 把 x 赋值给 y  */
  
   return;
}
```
当上面的代码被编译和执行时，它会产生下列结果：

```shell
交换前，a 的值： 100
交换前，b 的值： 200
交换前，a 的值： 100
交换前，b 的值： 200
交换后，a 的值： 200
交换后，b 的值： 100
```